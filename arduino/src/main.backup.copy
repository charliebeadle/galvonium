#include <Arduino.h>
#include <stdint.h>
#include <SPI.h>

#define DAC_FLAGS_A 0b00010000
#define DAC_FLAGS_B 0b10010000
#define LASER_PIN 3 // Pin for laser control

const uint16_t MAX_POINTS = 256; // points per frame - can't be higher than 256 since I use uint8_t for stuff
const uint8_t TARGET_FPS = 30;
const uint32_t TARGET_PPS = 10000;
const uint16_t MIN_POINTS_PER_FRAME = TARGET_PPS / TARGET_FPS; // minimum number of points to be drawn before next frame is loaded

// Interpolation parameters
const uint8_t BASE_POINTS_PER_LINE = 4;      // Base number of points per line segment
const uint8_t CORNER_POINTS = 2;             // Extra points to add at corners
const float CORNER_APPROACH_FACTOR = 0.3;    // Percentage of line length to start corner slowdown
const float CORNER_DENSITY_MULTIPLIER = 2.0; // Multiply point density near corners
const uint8_t CENTER_X = 127;
const uint8_t CENTER_Y = 127;

static uint32_t lastSwapTime = 0; // time of last swap in milliseconds

struct FrameBuffer
{
  uint16_t pointCount;                // number of points in frame - has to be uint16 JUST IN CASE there is EXACTLY 256 points. Don't want to start at 0 or overflow.
  uint8_t x[MAX_POINTS];              // x coordinates of points
  uint8_t y[MAX_POINTS];              // y coordinates of points
  uint8_t laserFlags[MAX_POINTS / 8]; // laser on or off - 8 points per byte
};

void initBuffer(FrameBuffer *buffer)
{
  buffer->pointCount = 0;
  memset(buffer->laserFlags, 0, sizeof(buffer->laserFlags));
}

// Segment classification flags (2 bits)
enum SegmentType
{
  STRAIGHT = 0,    // 00: No corners
  APPROACHING = 1, // 01: Heading into corner
  LEAVING = 2,     // 10: Exiting corner
  SHORT_CORNER = 3 // 11: Short line between corners
};

struct PathSegment
{
  uint8_t startX, startY;
  uint8_t endX, endY;
  SegmentType type;
  uint8_t interpSteps; // 0-255 interpolation steps
};

// Frame buffer entry (4 bytes)
struct LaserInstruction
{
  uint8_t targetX;
  uint8_t targetY;
  uint8_t flags;    // [7:6] reserved, [5:4] interp mode, [3:0] step count
  uint8_t moveTime; // Time multiplier (for speed control)
};

// Flag bit allocation:
// Bits 5-4: Interpolation Mode
//   00 = Linear (equal steps)
//   01 = Quadratic in (accelerate)
//   10 = Quadratic out (decelerate)
//   11 = Hold (for corners)
// Bits 3-0: Step Count (1-15 steps)

FrameBuffer bufferA;
FrameBuffer bufferB;

FrameBuffer *currentBuffer = &bufferA;
FrameBuffer *nextBuffer = &bufferB;

// Used by ISR
volatile uint16_t pointIndex = 0;  // current index in buffer
volatile uint16_t pointsDrawn = 0; // number of points drawn in current frame
volatile bool interruptReadyFlag = false;
volatile uint8_t x;
volatile uint8_t y;
volatile uint16_t packet;

void setLaserState(FrameBuffer *buffer, uint16_t index, bool state)
{
  uint8_t byteIndex = index >> 3;   // index / 8
  uint8_t bitIndex = index & 0b111; // index % 8

  if (state)
  {
    buffer->laserFlags[byteIndex] |= (1 << bitIndex); // set bit
  }
  else
  {
    buffer->laserFlags[byteIndex] &= ~(1 << bitIndex); // clear bit
  }
}

bool getLaserState(const FrameBuffer *buffer, uint16_t index)
{
  uint8_t byteIndex = index >> 3;   // index / 8
  uint8_t bitIndex = index & 0b111; // index % 8

  return (buffer->laserFlags[byteIndex] & (1 << bitIndex));
}

void outputDAC(uint8_t x, uint8_t y)
{
  uint16_t packetX = DAC_FLAGS_A << 8 | x << 4;
  uint16_t packetY = DAC_FLAGS_B << 8 | y << 4;

  PORTB &= ~(1 << PB2); // Set CS low
  SPI.transfer16(packetX);
  PORTB |= (1 << PB2); // Set CS high

  PORTB &= ~(1 << PB2); // Set CS low
  SPI.transfer16(packetY);
  PORTB |= (1 << PB2); // Set CS high
}

ISR(TIMER1_COMPA_vect)
{

  // This ISR is called at a fixed rate defined by TARGET_PPS.
  // It outputs the next point in the current buffer to the DAC.

  uint8_t flagByte = currentBuffer->laserFlags[pointIndex >> 3]; // pointIndex / 8
  bool laserOn = (flagByte & (1 << (pointIndex & 0b111))) != 0;  // pointIndex % 8
  digitalWrite(LASER_PIN, laserOn ? HIGH : LOW);                 // Set laser state

  x = currentBuffer->x[pointIndex];
  y = currentBuffer->y[pointIndex];
  outputDAC(x, y);

  pointIndex++;

  if (pointIndex == currentBuffer->pointCount)
  {
    pointIndex = 0;
    interruptReadyFlag = true;
  }
  else
  {
    interruptReadyFlag = false; // Not ready to swap yet.
  }
}

bool frameRateLimiter()
{
  uint32_t currentTime = millis();

  // Check if enough time has passed since the last swap.
  if (currentTime - lastSwapTime >= (1000 / TARGET_FPS))
  {
    lastSwapTime = currentTime;
    return true; // Time to swap frames.
  }

  return false; // Not yet time to swap frames.
}

bool swapReady()
{
  return interruptReadyFlag && frameRateLimiter();
}

void swap()
{
  noInterrupts(); // Disable interrupts.

  FrameBuffer *temp = currentBuffer;
  currentBuffer = nextBuffer;
  nextBuffer = temp;

  // Reset ISR state for the new frame.
  pointIndex = 0;
  interruptReadyFlag = false;

  lastSwapTime = millis(); // Update the last swap time.

  interrupts(); // Re-enable interrupts.
}

void initTimer()
{
  noInterrupts();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  OCR1A = (F_CPU / TARGET_PPS) - 1;
  TCCR1B |= (1 << WGM12);  // CTC mode.
  TCCR1B |= (1 << CS10);   // No prescaling.
  TIMSK1 |= (1 << OCIE1A); // Enable Timer1 compare interrupt.
  interrupts();
}

void addPoint(uint8_t x, uint8_t y)
{
  Serial.println("Adding point: ");
  Serial.print("X: ");
  Serial.print(x);
  Serial.print(" Y: ");
  Serial.println(y);
  nextBuffer->x[nextBuffer->pointCount] = x;
  nextBuffer->y[nextBuffer->pointCount] = y;
  nextBuffer->pointCount++;
}

void drawSquareSpiral(uint8_t centerX, uint8_t centerY, uint8_t stepSize, uint16_t pointCount)
{
  initBuffer(nextBuffer);
  uint8_t stepCount = 1;
  bool negate = false;
  uint8_t x = centerX;
  uint8_t y = centerY;

  while (nextBuffer->pointCount < MAX_POINTS && x < 255 && y < 255)
  {
    addPoint(x, y); // Add the center point
    for (uint8_t i = 0; i < stepCount; i++)
    {
      if (negate)
      {
        x -= stepSize; // Move left
      }
      else
      {
        x += stepSize; // Move right
      }
      addPoint(x, y);
    }
    addPoint(x, y); // Add the corner point

    for (uint8_t i = 0; i < stepCount; i++)
    {
      if (negate)
      {
        y -= stepSize; // Move up
      }
      else
      {
        y += stepSize; // Move down
      }
      addPoint(x, y);
    }

    addPoint(x, y); // Add the corner point

    stepCount++;
    negate = !negate; // Alternate direction
  }
}

void setup()
{
  initTimer();

  Serial.begin(9600);

  DDRB |= (1 << PB2);
  PORTB &= ~(1 << PB2);

  SPI.begin();
  SPI.beginTransaction(SPISettings(20000000, MSBFIRST, SPI_MODE0));
  Serial.println("hello");
}

char serialBuffer[256];
uint8_t bufferIndex = 0;

void processSerialCommand()
{
  // Find parameter name and value
  char *name = strtok(serialBuffer, ":");
  char *valueStr = strtok(NULL, ":");

  if (!name || !valueStr)
    return;

  float value = atof(valueStr);

  // Update parameter
  // if (strcmp(name, "rotation_speed") == 0)
  // {
  //   rotation_speed = constrain(value, 0.0, 1.0);
  // }
  // else if (strcmp(name, "laser_power") == 0)
  // {
  //   laser_power = constrain(value, 0.0, 1.0);
  // }
  // else if (strcmp(name, "corner_density") == 0)
  // {
  //   corner_density = constrain(value, 1, 10);
  // }
  // else if (strcmp(name, "scale_factor") == 0)
  // {
  //   scale_factor = constrain(value, 0.1, 2.0);
  // }

  // Echo back to confirm
  Serial.print(name);
  Serial.print(" set to ");
  Serial.println(value, 4);
}

void readSerial()
{
  while (Serial.available())
  {
    char c = Serial.read();

    if (c == '\n')
    {
      serialBuffer[bufferIndex] = '\0';
      processSerialCommand();
      bufferIndex = 0;
    }
    else if (bufferIndex < sizeof(serialBuffer) - 1)
    {
      serialBuffer[bufferIndex++] = c;
    }
  }
}



void loop()
{

  drawSquareSpiral(CENTER_X, CENTER_Y, 40, 255);

  while (!swapReady())
  {
    readSerial();
  }

  swap();
}